<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="../../../css/style-general.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sesi贸n 21</title>
  <!-- Formatear code. Agrega la hoja de estilo para el tema oscuro (por ejemplo, Dracula)-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/dracula.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
  <script>document.addEventListener('DOMContentLoaded', (event) => { hljs.highlightAll(); })</script>
</head>

<body>
  <nav class="nav heartbeat">
    <input type="checkbox" id="toggle-menu">
    <label for="toggle-menu" class="icono-hamburguesa"><span></span></label>  
    <ul>
      <li>Sesi贸n 10</li>
      <li><a href="../sesion10/index.html#and-or">And/Ord</a> </li>
      <li><a href="../sesion10/index.html#switch">Switch</a> </li>
      <li><a href="../sesion10/index.html#ciclo-for">For</a> </li>
      <li><a href="../sesion10/index.html#for-of-in">For of/in</a> </li>
      <li><a href="../sesion10/index.html#while">While</a> </li>
      <li>Sesi贸n 11</li>
      <li><a href="../sesion11/index.html#while-ejer-multiplos">While Ejer</a> </li>
      <li><a href="../sesion11/index.html#functions">Functions</a> </li>
      <li><a href="../sesion11/index.html#function-anonima">Function Anon</a> </li>
      <li><a href="../sesion11/index.html#function-arrow">Function Arrow</a> </li>
      <li><a href="../sesion11/index.html#arrays-ejer">Arrays</a> </li>
      <li><a href="../sesion11/index.html#for">For</a> </li>
      <li><a href="../sesion11/index.html#foreach">Foreach</a> </li>
      <li><a href="../sesion11/index.html#filter">Filter</a> </li>
      <li>Sesi贸n 12</li>
      <li><a href="../sesion12/index.html#filter-ejer">Filter Ejer</a> </li>
      <li><a href="../sesion12/index.html#promise">Promise</a> </li>
      <li><a href="../sesion12/index.html#async-await">Async/Await</a> </li>
      <li>Sesi贸n 13</li>
      <li><a href="../sesion13/index.html#promise-ejer">Promise Ejercicio</a> </li>
      <li><a href="../sesion13/index.html#import-export">Import / Export</a> </li>
      <li><a href="../sesion13/index.html#mod1-ppo">POO</a> </li>
      <li>Sesi贸n 14</li>
      <li><a href="../sesion14/index.html#prototipos">Prototipos</a> </li>
      <li>Sesi贸n 15</li>
      <li><a href="../sesion14/index.html#herencia">Herencia</a> </li>
      <li><a href="../sesion15/index.html#herencia-ejer">Herencia Ejercicios</a> </li>
      <li><a href="../sesion15/index.html#poliformismo">Poliformismo</a> </li>
      <li>Sesi贸n 16</li>
      <li><a href="../sesion16/index.html#arrays-metodos">Array M茅todos</a> </li>
      <li><a href="../sesion16/index.html#arrays-fill">Array / fill() </a></li>
      <li><a href="../sesion16/index.html#arrays-foreach">Array / forEach()</a> </li>
      <li><a href="../sesion16/index.html#arrays-filter">Array / filter()</a> </li>
      <li><a href="../sesion16/index.html#arrays-find">Array / find()</a> </li>
      <li><a href="../sesion16/index.html#arrays-map">Array / map()</a> </li>
      <li><a href="../sesion16/index.html#arrays-sort">Array / sort()</a> </li>
      <li><a href="../sesion16/index.html#arrays-tosorted">Array / toSorted()</a> </li>
      <li><a href="../sesion16/index.html#tarea-comparador">Tarea comparador</a> </li>
      <li>Sesi贸n 17</li>
      <li><a href="../sesion17/index.html#arrays-some">Array / some()</a> </li>
      <li><a href="../sesion17/index.html#arrays-filter-include">Array / filter() + include()</a> </li>
      <li><a href="../sesion17/index.html#arrays-every">Array / every()</a> </li>
      <li><a href="../sesion17/index.html#arrays-concat">Array / concat()</a> </li>
      <li><a href="../sesion17/index.html#arrays-include">Array / include()</a> </li>
      <li><a href="../sesion17/index.html#arrays-join">Array / join()</a> </li>
      <li><a href="../sesion17/index.html#arrays-reduce">Array / reduce()</a> </li>
      <li><a href="../sesion17/index.html#arrays-index-of">Array / indexOf()</a> </li>
      <li><a href="../sesion17/index.html#arrays-find-index">Array / findIndex()</a> </li>
      <li><a href="../sesion17/index.html#arrays-shift">Array / shift()</a> </li>
      <li><a href="../sesion17/index.html#arrays-unshift">Array / unshift()</a> </li>
      <li><a href="../sesion17/index.html#arrays-reverse">Array / reverse()</a> </li>
      <li><a href="../sesion17/index.html#arrays-toReverse">Array / toReverse()</a> </li>
      <li><a href="../sesion17/index.html#arrays-splice">Array / splice()</a> </li>
      <li>Sesi贸n 18</li>
      <li><a href="../sesion18/index.html#arrays-flat">Array / flat()</a> </li>
      <li><a href="../sesion18/index.html#arrays-isArray">Array / isArray()</a> </li>
      <li><a href="../sesion18/index.html#arrays-from">Array / from()</a> </li>
      <li><a href="../sesion18/index.html#rest-operador">Operador Rest</a> </li>
      <li><a href="../sesion18/index.html#spread-operador">Operador Espread</a> </li>
      <li>Sesi贸n 19</li>
      <li><a href="../sesion18/index.html#pilas">Pilas</a> </li>
      <li><a href="../sesion19/index.html#pilas-ejer">Pilas Ejercicios</a> </li>
      <li><a href="../sesion19/index.html#colas">Colas</a> </li>
      <li><a href="../sesion19/index.html#listas-enlazadas">Listas enlazadas</a> </li>
      <li><a href="../sesion19/index.html#tarea-lista-enlazada">Tarea listas enlazadas</a> </li>
      <li>Sesi贸n 20</li>
      <li><a href="../sesion20/index.html#lista-enlazada-ejer">Lista enlazada ejercicios</a></li>
      <li><a href="../sesion20/index.html#arbol-binario">rbol binario</a></li>
      <li>Sesi贸n 21</li>
      <li><a href="../sesion21/index.html#arboles-ejercicios">rbol binario ejercicios</a></li>
      <li><a href="../sesion21/index.html#grafos">Grafos</a></li>
      <li><a href="../sesion21/index.html#grafos-ejer">Grafos ejercicios</a></li>
      <li><a href="../sesion21/index.html#grafos-bfs">Grafos / BFS</a></li>
      <li><a href="../sesion21/index.html#grafos-dfs">Grafos / DFS</a></li>
      <li><a href="../sesion21/index.html#algoritmo-busqueda-lineal">Algoritmos / b煤squeda lineal</a></li>
      <li>Sesi贸n 22</li>
      <li><a href="../sesion22/index.html#algoritmo-busqueda-lineal">Algoritmos / B煤squeda binaria</a></li>
      <li><a href="../sesion22/index.html#algoritmo-quicksort">Algoritmos / Quicksort</a></li>
      <li><a href="../sesion22/index.html#algoritmo-mergesort">Algoritmos / MergeSort</a></li>
      <li>Sesi贸n 23</li>
      <li><a href="../sesion23/index.html#algoritmo-bubble-sort">Algoritmos / Bubble Sort</a></li>
      <li><a href="../sesion23/index.html#algoritmo-select-sort">Algoritmos / Select Sort</a></li>
      <li><a href="../sesion23/index.html#algoritmo-insertion-sort">Algoritmos / Insertion Sort</a></li>
      <li>Sesi贸n 24</li>
      <li><a href="../sesion24/index.html#algoritmo-radix-sort">Algoritmos / Radix Sort</a></li>
      <li><a href="../sesion24/index.html#json-web-token">Json Web Token - Parte 1</a></li>
      <li>Sesi贸n 25</li>
      <li><a href="../sesion25/index.html#json-web-token-dos">Json Web Token - Parte 2</a></li>
      <li><a href="../sesion25/index.html#crud-express-mongodb-uno">CRUD / Express y MongoDB - Parte 1</a></li>
      <li>Sesi贸n 26</li>
      <li><a href="../sesion26/index.html#crud-express-mongodb-dos">CRUD / Express y MongoDB - Parte 2</a></li>
      <li>Sesi贸n 27</li>
      <li><a href="../sesion27/index.html#crud-express-mongodb-tres">CRUD / Express y MongoDB - Parte 3</a></li>
      <li>Sesi贸n 28</li>
      <li><a href="../sesion28/index.html#crud-express-mysql-uno">CRUD / Express y MySql - Parte 1</a></li>
      <li>Sesi贸n 29</li>
      <li><a href="../sesion29/index.html#crud-express-mysql-dos">CRUD / Express y MySql - Parte 2</a></li>
      <li>Sesi贸n 30</li>
      <li><a href="../sesion30/index.html#react-uno">React - Parte 1</a></li>
      <li>Sesi贸n 31</li>
      <li><a href="../sesion31/index.html#react-dos">React - Parte 2</a></li>
      <li><a href="../sesion31/index.html#react-vite">React con Vite</a></li>
      <li><a href="../sesion31/index.html#react-ejer-card-one">React - Ejercicio Cards - Parte 1</a></li>
      <li>Sesi贸n 32</li>
      <li><a href="../sesion32/index.html#react-ejer-card-dos">React - Ejercicio Cards - Parte 2</a></li>
      <li><a href="../sesion32/index.html#react-actividad">React - Actividad</a></li>
      <li>Sesi贸n 33</li>
      <li><a href="../sesion33/index.html#react-hook">React - Hook</a></li>
      <li><a href="../sesion33/index.html#react-hook-use-state">React - Hook {useState}</a></li>
      <li><a href="../sesion33/index.html#react-hook-use-effect">React - Hook {useEffect}</a></li>
    </ul>
  </nav>
  <h1 id="sesion-21">SESIN 21</h1>
  <small class="fecha">09.04.2024 S21-M2</small>

  <article id="arboles-ejercicios">
    <h2>rbol binario ejercicios</h2>
    <p>Completando el <a href="https://informatecdigital.com/algoritmos/arboles-binarios-en-javascript-una-guia-completa/">ejercicio de la clase anterior, completo aqu铆</a></p>
    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// rbol binario
// Creamos la clase principal 'Nodo', con tres propiedades.
class Node {
  // 3 propiedades 
  constructor(valor){
    this.valor = valor;
    this.izq = null;
    this.der = null;
  }
}

// Creamos la clase 'rbol' con una sola propiedad
class Arbol{
  constructor(){
    this.raiz = null;
  }

  // Creamos un m茅todo a funci贸n de inserci贸n a nuestra clase 'Arbol', 
  Agregar(valor){
    const newNode = new Node(valor);
    if(this.raiz === null){
      this.raiz = newNode;
    }else
      this.AgregarNode(this.raiz, newNode);
  }

  // Creamos la funci贸n agregar a los nodos Izq o Der.
  AgregarNode(nodo, newNode){
    if(newNode.valor < nodo.valor){
      if(nodo.izq === null){
        nodo.izq = newNode;
      }else{
        this.AgregarNode(nodo.izq, newNode);
      }
    }else{
      if(nodo.der === null){
        nodo.der = newNode;
      }else{
        this.AgregarNode(nodo.der, newNode);
      }
    }
  }

  // Funci贸n buscar
  Buscar(valor){
    return this.BuscarNodo(this.raiz, valor)
  }
  // Funci贸n Buscar nodo
  BuscarNodo(nodo, valor){
    if(nodo === null || nodo.valor === valor ){
      return nodo;
    }else if(valor < nodo.valor){
      return this.BuscarNodo(nodo.izq, valor)
    }else{
      return this.BuscarNodo(nodo.der, valor)
    }
  }

  // Funci贸n eliminar nodo
  eliminar(valor){
    this.raiz = this.eliminarNodo(this.raiz, valor);
  }
  eliminarNodo(nodo, valor) {
    if (nodo === null) {
      return null;
    } else if (valor < nodo.valor) {
      nodo.izq = this.eliminarNodo(nodo.izq, valor);
      return nodo;
    } else if (valor > nodo.valor) {
      nodo.der = this.eliminarNodo(nodo.der, valor);
      return nodo;
    } else {
      if (nodo.izq === null && nodo.der === null) {
        return null;
      } else if (nodo.izq === null) {
        return nodo.der;
      } else if (nodo.der === null) {
        return nodo.izq;
      } else {
        const sucesor = this.encontrarSucesor(nodo.der);
        nodo.valor = sucesor.valor;
        nodo.der = this.eliminarNodo(nodo.der, sucesor.valor);
        return nodo;
      }
    }
  }
  // Funci贸n  para encontrar el lugar donde ubicar a el valor eliminado
  encontrarSucesor(nodo) {
    let sucesor = nodo;
    while (sucesor.izq !== null) {
      sucesor = sucesor.izq;
    }
    return sucesor;
  }


  // Recorrido en orden de un 谩rbol binario
  recorridoEnOrden() {
    this.recorrerEnOrden(this.raiz);
  }
  recorrerEnOrden(nodo) {
    if (nodo !== null) {
      this.recorrerEnOrden(nodo.izq);
      console.log(nodo.valor);
      this.recorrerEnOrden(nodo.der);
    }
  }

  // Recorrido en pre-orden
  recorridoPreOrden() {
    this.recorrerPreOrden(this.raiz);
  }
  recorrerPreOrden(nodo) {
    if (nodo !== null) {
      console.log(nodo.valor);
      this.recorrerPreOrden(nodo.izq);
      this.recorrerPreOrden(nodo.der);
    }
  }

  // Recorrido en post-orden
  recorridoPostOrden() {
    this.recorrerPostOrden(this.raiz);
  }
  
  recorrerPostOrden(nodo) {
    if (nodo !== null) {
      this.recorrerPostOrden(nodo.izq);
      this.recorrerPostOrden(nodo.der);
      console.log(nodo.valor);
    }
  }
}

// comprobando la funci贸n Agregar()
const newArbol = new Arbol();
newArbol.Agregar("D");
console.log(newArbol);
newArbol.Agregar("B");
console.log(newArbol);
newArbol.Agregar("C");
console.log(newArbol);
newArbol.Agregar("a");
console.log(newArbol);
newArbol.Agregar("A");
console.log(newArbol);
newArbol.Agregar("c");
console.log(newArbol);
newArbol.Agregar("b");
console.log(newArbol);

// Comprobante de la funci贸n EliminarNodo()
console.log(newArbol.eliminar("C"));

// Comprobando recorrido en orden
console.log("Comprobando recorrido en orden");
console.log(newArbol.recorridoEnOrden());

// Comprobando recorrido en pre-orden
console.log("Comprobando recorrido en pre-orden");
console.log(newArbol.recorridoPreOrden());

// Comprobando recorrido en post-orden
console.log("Comprobando recorrido en post-orden");
console.log(newArbol.recorridoPostOrden());
        
      </code>
    </pre>  
  </article>


  <article id="grafos">
    <h2>Grafos</h2>
    <p>Los grafos en JavaScript son estructuras de datos que consisten en un conjunto de nodos (v茅rtices) conectados entre s铆 por aristas (aristas). Pueden ser dirigidos o no dirigidos y se utilizan para representar una amplia variedad de relaciones, desde redes sociales hasta mapas de carreteras. En JavaScript, los grafos se pueden implementar utilizando objetos y arrays, donde los nodos son objetos y las aristas son arrays de nodos o parejas de nodos. Las operaciones comunes en grafos incluyen a帽adir y eliminar nodos y aristas, buscar caminos entre nodos, y realizar recorridos para explorar el grafo en diferentes maneras.</p>
    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// We create a class for the graph
class Graph{
    // The graph has only one property which is the adjacency list
    constructor() {
        this.adjacencyList = {}
    }
    // The addNode method takes a node value as parameter and adds it as a key to the adjacencyList if it wasn't previously present
    addNode(node) {
        if (!this.adjacencyList[node]) this.adjacencyList[node] = []
    }
    // The addConnection takes two nodes as parameters, and it adds each node to the other's array of connections.
    addConnection(node1,node2) {
        this.adjacencyList[node1].push(node2)
        this.adjacencyList[node2].push(node1)
    }
    // The removeConnection takes two nodes as parameters, and it removes each node from the other's array of connections.
    removeConnection(node1,node2) {
        this.adjacencyList[node1] = this.adjacencyList[node1].filter(v => v !== node2)
        this.adjacencyList[node2] = this.adjacencyList[node2].filter(v => v !== node1)
    }
    // The removeNode method takes a node value as parameter. It removes all connections to that node present in the graph and then deletes the node key from the adj list.
    removeNode(node){
        while(this.adjacencyList[node].length) {
            const adjacentNode = this.adjacencyList[node].pop()
            this.removeConnection(node, adjacentNode)
        }
        delete this.adjacencyList[node]
    }
}
const spain = new Graph()
spain.addNode("Cordoba")
spain.addNode("Sevilla")
spain.addNode("Toledo")
spain.addNode("Madrid")
spain.addConnection("Sevilla", "Cordoba")
spain.addConnection("Cordoba", "Toledo")
spain.addConnection("Toledo", "Madrid")
console.log(spain)
// Graph {
//   adjacencyList: {
//     Cordoba: [ 'Sevilla', 'Toledo' ],
//     Sevilla: [ 'Cordoba' ],
//     Toledo: [ 'Cordoba', 'Madrid' ],
//     Madrid: [ 'Toledo' ]
//   }
// }      

      </code>
    </pre>  

    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// Ejemplo web
// We create a class for the graph
class Graph{
  // The graph has only one property which is the adjacency list
  constructor() {
      this.adjacencyList = {}
  }
  // The addNode method takes a node value as parameter and adds it as a key to the adjacencyList if it wasn't previously present
  addNode(node) {
      if (!this.adjacencyList[node]) this.adjacencyList[node] = []
  }
  // The addConnection takes two nodes as parameters, and it adds each node to the other's array of connections.
  addConnection(node1,node2) {
      this.adjacencyList[node1].push(node2)
      this.adjacencyList[node2].push(node1)
  }
  // The removeConnection takes two nodes as parameters, and it removes each node from the other's array of connections.
  removeConnection(node1,node2) {
      this.adjacencyList[node1] = this.adjacencyList[node1].filter(v => v !== node2)
      this.adjacencyList[node2] = this.adjacencyList[node2].filter(v => v !== node1)
  }
  // The removeNode method takes a node value as parameter. It removes all connections to that node present in the graph and then deletes the node key from the adj list.
  removeNode(node){
      while(this.adjacencyList[node].length) {
          const adjacentNode = this.adjacencyList[node].pop()
          this.removeConnection(node, adjacentNode)
      }
      delete this.adjacencyList[node]
  }
}
const spain = new Graph()
spain.addNode("Cordoba")
spain.addNode("Sevilla")
spain.addNode("Toledo")
spain.addNode("Madrid")
spain.addConnection("Sevilla", "Cordoba")
spain.addConnection("Cordoba", "Toledo")
spain.addConnection("Toledo", "Madrid")
console.log(spain)
// Graph {
//   adjacencyList: {
//     Cordoba: [ 'Sevilla', 'Toledo' ],
//     Sevilla: [ 'Cordoba' ],
//     Toledo: [ 'Cordoba', 'Madrid' ],
//     Madrid: [ 'Toledo' ]
//   }
// }

      </code>
    </pre>  

    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
//Ejemplo 2
class Grafo{
  // Solo maneja una sola propiedad
  constructor(){
    this.adjacencyList = {};
  }

  // Creamos la funci贸n que tomar谩 el valor del nodo como par谩metro y lo agrega como
  //  par谩metro y lo agrega como clave a adjacencyList
  addVertices(node){
    if(!this.adjacencyList[node]) this.adjacencyList[node] = [];
  }
  // Toma dos nodos como par谩metros y lo agrega cada nodo a la matrix de conexionas
  addArista(node1, node2){
    this.adjacencyList[node1].push(node2);
    this.adjacencyList[node2].push(node1); // Trabajando con nodos no dirigidos
  }
  // Va a tomar 2 nodos como par谩metros y agrega cada nodo a la matrix de conexi贸n
  addArista2(node1, node2){
    this.adjacencyList[node1].push(node2); // Trabajando con nodos dirigidos
  }

}

const lista = new Grafo();
lista.addVertices("A");
lista.addVertices("B");
lista.addVertices("C");
lista.addVertices("D");
lista.addVertices("E");
console.log("Grafo no dirigido");
console.log(lista);
// Grafo no dirigido
lista.addArista("A", "B");
lista.addArista("A", "C");
lista.addArista("C", "D");
lista.addArista("D", "E");
console.log(lista);


const lista2 = new Grafo();
lista2.addVertices("A");
lista2.addVertices("B");
lista2.addVertices("C");
lista2.addVertices("D");
lista2.addVertices("E");
console.log("Grafo dirigido");

// Grafo dirigido
lista2.addArista2("A", "B");
lista2.addArista2("B", "C");
lista2.addArista2("C", "E");
lista2.addArista2("E", "F");
lista2.addArista2("E", "D");
lista2.addArista2("D", "B");
console.log(lista2);

      </code>
    </pre>  
    <p><a href="https://jovid.win/estructuras-de-datos-en-javascript/#graphs">Afianza conocimientos sobre grafos</a></p>
  </article>

  <article id="grafos-ejer">
    <h2>Grafos / Departamentos y Capitales</h2>
    <p>Realizar un grafo donde tengan departamentos de Colombia y deben crear un enlace con su respectiva ciudad, es dirigido:</p>
    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js - Soluci贸n ejercicio:</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// Soluci贸n ejercicio:
class Grafo{
  // Solo maneja una sola propiedad
  constructor(){
    this.adjacencyList = {};
  }

  // Creamos la funci贸n que tomar谩 el valor del nodo como par谩metro y lo agrega como
  //  parametro y lo agrega como clave a adjacencyList
  addVertices(node){
    if(!this.adjacencyList[node]) this.adjacencyList[node] = [];
  }
  // Toma dos nodos como par谩metros y lo agrega cada nodo a la matrix de conexionas
  addArista(node1, node2){
    this.adjacencyList[node1].push(node2);
    this.adjacencyList[node2].push(node1); // Trabajando con nodos no dirigidos
  }
  // Va a tomar 2 nodos como par谩metros y agrega cada nodo a la matrix de conexi贸n
  addArista2(node1, node2){
    this.adjacencyList[node1].push(node2); // Trabajando con nodos dirigidos
  }

}

const departamento = new Grafo();

departamento.addVertices("Cundinamarca");
departamento.addVertices("Bogot谩");
departamento.addVertices("Antioquia");
departamento.addVertices("Medellin");
departamento.addVertices("Valle del Cauca");
departamento.addVertices("Cali");
departamento.addVertices("Atl谩ntico");
departamento.addVertices("Barranquilla");

departamento.addArista2("Cundinamarca", "Bogot谩");
departamento.addArista2("Antioquia", "Medellin");
departamento.addArista2("Valle del Cauca", "Cali");
departamento.addArista2("Atl谩ntico", "Barranquilla");


console.log(departamento); 

      </code>
    </pre>  

    <p><a href="https://jovid.win/estructuras-de-datos-en-javascript/#graphs">Afianza conocimientos sobre grafos</a></p>
  </article>

  <article id="grafos-bfs">
    <h2>Grafos / BFS</h2>
    <p>El BFS (Breadth-First Search) o B煤squeda en Anchura es un algoritmo de recorrido de grafos que explora todos los nodos vecinos de un nodo dado antes de pasar a los nodos vecinos de esos nodos. Utiliza una estructura de datos cola para mantener un registro de los nodos por visitar. Es 煤til para encontrar el camino m谩s corto en un grafo no ponderado y para descubrir la estructura de un grafo. En JavaScript, se puede implementar BFS utilizando una cola y un conjunto para registrar nodos visitados, y se puede aplicar en diversos escenarios como navegaci贸n web, recomendaciones de amigos en redes sociales, y resoluci贸n de problemas en inteligencia artificial, entre otros.</p>
    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js - Soluci贸n ejercicio:</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// Ejemplo 2 - usando prototipos y ALGORITMO 'BFS' https://www.youtube.com/watch?v=_Yf8tneauJ8&t=2s y ejercicio en https://medium.com/@05.ankitarora/searching-algorithms-bfs-and-dfs-in-javascript-with-examples-306d176006de
class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addNode(node) {
    this.adjList.set(node, []);
  }

  addEdge(node, neighbor) {
    this.adjList.get(node).push(neighbor);
    this.adjList.get(neighbor).push(node);
  }

  bfs(startNode) {
    const visited = new Set();
    const queue = [startNode];
    
    visited.add(startNode);

    while (queue.length !== 0) {
      const current = queue.shift();
      console.log(current);

      const neighbors = this.adjList.get(current);

      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }
  }
}

// Example Usage
const graph = new Graph();

graph.addNode('A');
graph.addNode('B');
graph.addNode('C');
graph.addNode('D');
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('B', 'D');

graph.bfs('A');
console.log(graph);
console.log(graph.bfs('A'));

      </code>
    </pre>  

    <p><a href="https://www.youtube.com/watch?v=_Yf8tneauJ8&t=2s y ejercicio en https://medium.com/@05.ankitarora/searching-algorithms-bfs-and-dfs-in-javascript-with-examples-306d176006de">Afianza conocimientos sobre algoritmos BFS</a></p>
  </article>

  <article id="grafos-dfs">
    <h2>Grafos / DFS</h2>
    <p>El DFS (Depth-First Search) o B煤squeda en Profundidad es un algoritmo de recorrido de grafos que sigue una rama del 谩rbol de expansi贸n hasta llegar a un nodo hoja antes de retroceder y explorar las ramas no exploradas. Utiliza una estructura de datos pila o recursi贸n para mantener un registro de los nodos por visitar. Es 煤til para encontrar ciclos en grafos, recorrer y buscar en estructuras de datos como 谩rboles y grafos, y para la topolog铆a y ordenamiento topol贸gico. En JavaScript, se puede implementar DFS de manera recursiva o iterativa, y se aplica en algoritmos de b煤squeda en bases de datos, resoluci贸n de laberintos, y sistemas de recomendaci贸n, entre otros.</p>
    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js - Soluci贸n ejercicio:</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// Ejemplo 3 - usando prototipos y ALGORITMO 'DFS' https://www.youtube.com/watch?v=_Yf8tneauJ8&t=2s y ejercicio en https://medium.com/@05.ankitarora/searching-algorithms-bfs-and-dfs-in-javascript-with-examples-306d176006de
class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addNode(node) {
    this.adjList.set(node, []);
  }

  addEdge(node, neighbor) {
    this.adjList.get(node).push(neighbor);
    this.adjList.get(neighbor).push(node);
  }

  dfs(node, visited = new Set()) {
    console.log(node);
    visited.add(node);

    const neighbors = this.adjList.get(node);

    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        this.dfs(neighbor, visited);
      }
    }
  }
}

// Example Usage
const graph = new Graph();

graph.addNode('A');
graph.addNode('B');
graph.addNode('C');
graph.addNode('D');
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('B', 'D');

graph.dfs('A');

      </code>
    </pre>  

    <p><a href="https://www.youtube.com/watch?v=_Yf8tneauJ8&t=2s y ejercicio en https://medium.com/@05.ankitarora/searching-algorithms-bfs-and-dfs-in-javascript-with-examples-306d176006de">Afianza conocimientos sobre algoritmos DFS</a></p>
  </article>

  <article id="algoritmo-busqueda-lineal">
    <h2>Algoritmos / b煤squeda lineal</h2>
    <p>La b煤squeda lineal, tambi茅n conocida como b煤squeda secuencial, es un m茅todo simple y directo para encontrar un elemento en una lista o array. En JavaScript, este algoritmo recorre el array elemento por elemento hasta encontrar el valor buscado o llegar al final del array. Es sencillo de implementar, pero no es el m谩s eficiente para listas grandes. Su complejidad es O(n), donde n es el n煤mero de elementos en el array. Aunque no es el algoritmo m谩s r谩pido, es 煤til cuando no se conoce la estructura o cuando la lista no est谩 ordenada.</p>
    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js - Soluci贸n ejercicio:</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// Algoritmos de b煤squeda lineal
let array1 = [1,2,3,4,5,6,7,8,9];

function BusquedaLineal(array1, val){
  for(let i = 0; i < array1.length; i++){
    if(array1[i] == val){
      return i;
    }
  }
  return -1;
} 

console.log(BusquedaLineal(array1, 9));      

      </code>
    </pre>  

    <pre class="dark">
      <div class="pre-head">
        <span class="tag js">js - Soluci贸n ejercicio:</span>
        <button class="copy-button"> Copiar c贸digo</button>
      </div>
      <code class="language-js">
// Algoritmos de b煤squeda lineal forma 2 -error!

let arregloLetras = ["a", "b","c","d","e","f",]
function buscador(elem, arregloLetras){
  for(let i = in arregloLetras){
    if(arregloLetras[i] == elem) return i; 
  }
  return -1;
}

console.log(buscador("d", arregloLetras));
      </code>
    </pre>  

  </article>

 




  <footer>
    Bryan Hern谩ndez | Telento Tech DWFSV2-42 | 2024
  </footer>
  <script src="../../../js/js-general.js"></script>
  <script src="sesion21.js" type="module"></script>
</body>

</html>